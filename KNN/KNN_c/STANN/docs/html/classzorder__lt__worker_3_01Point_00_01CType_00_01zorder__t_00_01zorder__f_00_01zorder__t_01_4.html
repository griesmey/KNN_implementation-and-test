<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>STANN: zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt; Class Template Reference</h1><!-- doxytag: class="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;" -->Z-Order work class specialized for Seperated Floating Point types.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="zorder__lt_8hpp-source.html">zorder_lt.hpp</a>&gt;</code>
<p>
<a href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#15c311d42743d813e54240e5144ee1f0">zorder_lt_worker</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#15c311d42743d813e54240e5144ee1f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#84a7db5dfd8b56253c70c5be7545b3b6">~zorder_lt_worker</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor.  <a href="#84a7db5dfd8b56253c70c5be7545b3b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#fab90337e615d324b4a532f8f0dff37a">operator()</a> (const Point &amp;p, const Point &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls less than operator.  <a href="#fab90337e615d324b4a532f8f0dff37a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#c64c6e2907e2cc8f1548de93d575bda6">dist_sq_to_quad_box</a> (const Point &amp;q, const Point &amp;p1, const Point &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the distance from a query point to the smallest quadtree box containing two other points.  <a href="#c64c6e2907e2cc8f1548de93d575bda6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#1232d09a5498d7c578cc1846c295fd8f">quad_box_length</a> (const Point &amp;p1, const Point &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the side length of the smallest quadtree box containing two points.  <a href="#1232d09a5498d7c578cc1846c295fd8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#cdee8325455e095b17778162fbdbcc83">min_quad_box</a> (const Point &amp;p1, const Point &amp;p2, Point &amp;lcorner, Point &amp;ucorner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the lower and upper corners of the smallest quadtree box containing two points.  <a href="#cdee8325455e095b17778162fbdbcc83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt__worker_3_01Point_00_01CType_00_01zorder__t_00_01zorder__f_00_01zorder__t_01_4.html#5a1648c1fc62f44c0e740a515a6a77d9">dist_sq_between_quad_boxes</a> (const Point &amp;q1, const Point &amp;q2, const Point &amp;p1, const Point &amp;p2, double &amp;dist, double &amp;radius1, double &amp;radius2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the distance between two quadtree boxes defined by two sets of two points.  <a href="#5a1648c1fc62f44c0e740a515a6a77d9"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Point, typename CType&gt;<br>
 class zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;</h3>

Z-Order work class specialized for Seperated Floating Point types. 
<p>
Z-Order work class (Seperated Floating Point)<p>
This class computes Z-order less than operations and the distance to a quadtree box for points with coordinate types that are seperated floating point types. The sfcnn algorithm automatically converts float, double and long double into the matching seperated type at construction, to save time on calculations. zorder_lt_worker is designed to be called by the <a class="el" href="classzorder__lt.html">zorder_lt</a> class. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="15c311d42743d813e54240e5144ee1f0"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::zorder_lt_worker" ref="15c311d42743d813e54240e5144ee1f0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::zorder_lt_worker           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
Constructor 
</div>
</div><p>
<a class="anchor" name="84a7db5dfd8b56253c70c5be7545b3b6"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::~zorder_lt_worker" ref="84a7db5dfd8b56253c70c5be7545b3b6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::~zorder_lt_worker           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default destructor. 
<p>
Destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5a1648c1fc62f44c0e740a515a6a77d9"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::dist_sq_between_quad_boxes" ref="5a1648c1fc62f44c0e740a515a6a77d9" args="(const Point &amp;q1, const Point &amp;q2, const Point &amp;p1, const Point &amp;p2, double &amp;dist, double &amp;radius1, double &amp;radius2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::dist_sq_between_quad_boxes           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>radius2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the distance between two quadtree boxes defined by two sets of two points. 
<p>
Distance (Squared) between two Quadtree Boxs<p>
This function first computes the minimum enclosing quadtree boxs for two sets of two points, then computes the minimum distance between them. If the boxes overlap, the distance will be 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q1</em>&nbsp;</td><td>First point defining first box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q2</em>&nbsp;</td><td>Second point defining first box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point defining second box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point defining second box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dist</em>&nbsp;</td><td>Return value, squared distance between quadtree boxes, 0 if overlap </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius1</em>&nbsp;</td><td>Return value, side length of the first quadtree box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius2</em>&nbsp;</td><td>Return value, side length of the second quadtree box </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c64c6e2907e2cc8f1548de93d575bda6"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::dist_sq_to_quad_box" ref="c64c6e2907e2cc8f1548de93d575bda6" args="(const Point &amp;q, const Point &amp;p1, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::dist_sq_to_quad_box           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the distance from a query point to the smallest quadtree box containing two other points. 
<p>
Distance (Squared) to Quadtree Box<p>
This function first computes the minimum enclosing quadtree box for two points, then computes the square distance from the query point to that quadtree box. If the query point lies within the quadtree box, the distance returned will be 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Query point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First quadtree box defining point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second quadtree box defining point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Squared distance from q to quadtree box. 0 if q lies within box </dd></dl>

</div>
</div><p>
<a class="anchor" name="cdee8325455e095b17778162fbdbcc83"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::min_quad_box" ref="cdee8325455e095b17778162fbdbcc83" args="(const Point &amp;p1, const Point &amp;p2, Point &amp;lcorner, Point &amp;ucorner)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::min_quad_box           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&nbsp;</td>
          <td class="paramname"> <em>lcorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&nbsp;</td>
          <td class="paramname"> <em>ucorner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the lower and upper corners of the smallest quadtree box containing two points. 
<p>
Minimum Enclosing Quadtree Box <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lcorner</em>&nbsp;</td><td>Return value, lower corner </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ucorner</em>&nbsp;</td><td>Return value, upper corner </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fab90337e615d324b4a532f8f0dff37a"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::operator()" ref="fab90337e615d324b4a532f8f0dff37a" args="(const Point &amp;p, const Point &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls less than operator. 
<p>
Function Object Operator<p>
This function determines whether one point preceeds the other in a Z-ordering <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Second point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if p comes before q in the Z-ordering of the points </dd></dl>

</div>
</div><p>
<a class="anchor" name="1232d09a5498d7c578cc1846c295fd8f"></a><!-- doxytag: member="zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::quad_box_length" ref="1232d09a5498d7c578cc1846c295fd8f" args="(const Point &amp;p1, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point, typename CType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double zorder_lt_worker&lt; Point, CType, zorder_t, zorder_f, zorder_t &gt;::quad_box_length           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the side length of the smallest quadtree box containing two points. 
<p>
Quadtree Box Length <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The side length of the smallest quadtree box containing p1 and p2 </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="zorder__lt_8hpp-source.html">zorder_lt.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Oct 30 02:04:20 2010 for STANN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
