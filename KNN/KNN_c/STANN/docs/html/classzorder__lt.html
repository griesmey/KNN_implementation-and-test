<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>STANN: zorder_lt&lt; Point &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>zorder_lt&lt; Point &gt; Class Template Reference</h1><!-- doxytag: class="zorder_lt" -->Wrapper class for various Z-Order operations.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="zorder__lt_8hpp-source.html">zorder_lt.hpp</a>&gt;</code>
<p>
<a href="classzorder__lt-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#edd1934a1c3b61cc76c8ea7a6add7ff2">zorder_lt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#edd1934a1c3b61cc76c8ea7a6add7ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#095a3f29b6511ac83f4312925de92b8a">~zorder_lt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Destructor.  <a href="#095a3f29b6511ac83f4312925de92b8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#3e8d6df805b0da9d5135a1f84655aaf4">operator()</a> (const Point &amp;p, const Point &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls less than operator.  <a href="#3e8d6df805b0da9d5135a1f84655aaf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#e70e043cb22856dba4a6931c826a244f">operator()</a> (const <a class="el" href="classMypair.html">Mypair</a>&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;p, const <a class="el" href="classMypair.html">Mypair</a>&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls less than operator.  <a href="#e70e043cb22856dba4a6931c826a244f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#e2a2b5da7d88978bbf82fe5df052803e">dist_sq_to_quad_box</a> (const Point &amp;q, const Point &amp;p1, const Point &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the distance from a query point to the smallest quadtree box containing two other points.  <a href="#e2a2b5da7d88978bbf82fe5df052803e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#0241c400bdaff834d25aff85d041bcef">dist_sq_between_quad_boxes</a> (const Point &amp;q1, const Point &amp;q2, const Point &amp;p1, const Point &amp;p2, double &amp;dist, double &amp;radius1, double &amp;radius2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the distance between two quadtree boxes defined by two sets of two points.  <a href="#0241c400bdaff834d25aff85d041bcef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#f293a73788b7bb5d226b1217c7910ede">min_quad_box</a> (const Point &amp;p1, const Point &amp;p2, Point &amp;lcorner, Point &amp;ucorner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the lower and upper corners of the smallest quadtree box containing two points.  <a href="#f293a73788b7bb5d226b1217c7910ede"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzorder__lt.html#823e7819d7bcfe0e466c755c8e5347f9">quad_box_length</a> (const Point &amp;p1, const Point &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the side length of the smallest quadtree box containing two points.  <a href="#823e7819d7bcfe0e466c755c8e5347f9"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Point&gt;<br>
 class zorder_lt&lt; Point &gt;</h3>

Wrapper class for various Z-Order operations. 
<p>
Z-order Less Than Operator<p>
This class provides an interface with several specialized worker classes which control some functions based on the Z-order of multi-dimensional points. The actual work is done by the zorder_lt_worker class, which is specialized based on the type of coordinates being used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Point</em>&nbsp;</td><td>The point type being used. </td></tr>
  </table>
</dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="edd1934a1c3b61cc76c8ea7a6add7ff2"></a><!-- doxytag: member="zorder_lt::zorder_lt" ref="edd1934a1c3b61cc76c8ea7a6add7ff2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::<a class="el" href="classzorder__lt.html">zorder_lt</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
Constructor<p>
The constructor will check that the type of coordinate used in the point type has had the appropriate traits defined in <a class="el" href="zorder__type__traits_8hpp.html">zorder_type_traits.hpp</a> 
</div>
</div><p>
<a class="anchor" name="095a3f29b6511ac83f4312925de92b8a"></a><!-- doxytag: member="zorder_lt::~zorder_lt" ref="095a3f29b6511ac83f4312925de92b8a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::~<a class="el" href="classzorder__lt.html">zorder_lt</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default Destructor. 
<p>
Destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0241c400bdaff834d25aff85d041bcef"></a><!-- doxytag: member="zorder_lt::dist_sq_between_quad_boxes" ref="0241c400bdaff834d25aff85d041bcef" args="(const Point &amp;q1, const Point &amp;q2, const Point &amp;p1, const Point &amp;p2, double &amp;dist, double &amp;radius1, double &amp;radius2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::dist_sq_between_quad_boxes           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>radius2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the distance between two quadtree boxes defined by two sets of two points. 
<p>
Distance (Squared) between two Quadtree Boxs<p>
This function first computes the minimum enclosing quadtree boxs for two sets of two points, then computes the minimum distance between them. If the boxes overlap, the distance will be 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q1</em>&nbsp;</td><td>First point defining first box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q2</em>&nbsp;</td><td>Second point defining first box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point defining second box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point defining second box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dist</em>&nbsp;</td><td>Return value, squared distance between quadtree boxes, 0 if overlap </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius1</em>&nbsp;</td><td>Return value, side length of the first quadtree box </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius2</em>&nbsp;</td><td>Return value, side length of the second quadtree box </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e2a2b5da7d88978bbf82fe5df052803e"></a><!-- doxytag: member="zorder_lt::dist_sq_to_quad_box" ref="e2a2b5da7d88978bbf82fe5df052803e" args="(const Point &amp;q, const Point &amp;p1, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::dist_sq_to_quad_box           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the distance from a query point to the smallest quadtree box containing two other points. 
<p>
Distance (Squared) to Quadtree Box<p>
This function first computes the minimum enclosing quadtree box for two points, then computes the square distance from the query point to that quadtree box. If the query point lies within the quadtree box, the distance returned will be 0. This function calls the appropriate function in the specialized z_order_worker class. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Query point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First quadtree box defining point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second quadtree box defining point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Squared distance from q to quadtree box. 0 if q lies within box </dd></dl>

</div>
</div><p>
<a class="anchor" name="f293a73788b7bb5d226b1217c7910ede"></a><!-- doxytag: member="zorder_lt::min_quad_box" ref="f293a73788b7bb5d226b1217c7910ede" args="(const Point &amp;p1, const Point &amp;p2, Point &amp;lcorner, Point &amp;ucorner)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::min_quad_box           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&nbsp;</td>
          <td class="paramname"> <em>lcorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&nbsp;</td>
          <td class="paramname"> <em>ucorner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the lower and upper corners of the smallest quadtree box containing two points. 
<p>
Minimum Enclosing Quadtree Box <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lcorner</em>&nbsp;</td><td>Return value, lower corner </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ucorner</em>&nbsp;</td><td>Return value, upper corner </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e70e043cb22856dba4a6931c826a244f"></a><!-- doxytag: member="zorder_lt::operator()" ref="e70e043cb22856dba4a6931c826a244f" args="(const Mypair&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;p, const Mypair&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMypair.html">Mypair</a>&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMypair.html">Mypair</a>&lt; typename std::vector&lt; Point &gt;::iterator, typename std::vector&lt; long unsigned int &gt;::iterator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls less than operator. 
<p>
Function Object Operator<p>
This function determines whether one point preceeds the other in a Z-ordering. In this instance of the function, the points are taken from a <a class="el" href="classMypair.html">Mypair</a> of iterator types. This is used to sort two vectors simultaneously. See <a class="el" href="pair__iter_8hpp.html">pair_iter.hpp</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Second point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if p comes before q in the Z-ordering of the points </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e8d6df805b0da9d5135a1f84655aaf4"></a><!-- doxytag: member="zorder_lt::operator()" ref="3e8d6df805b0da9d5135a1f84655aaf4" args="(const Point &amp;p, const Point &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls less than operator. 
<p>
Function Object Operator<p>
This function determines whether one point preceeds the other in a Z-ordering by calling the appropriate function in the specialized z_order_worker class <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>Second point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if p comes before q in the Z-ordering of the points </dd></dl>

</div>
</div><p>
<a class="anchor" name="823e7819d7bcfe0e466c755c8e5347f9"></a><!-- doxytag: member="zorder_lt::quad_box_length" ref="823e7819d7bcfe0e466c755c8e5347f9" args="(const Point &amp;p1, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classzorder__lt.html">zorder_lt</a>&lt; Point &gt;::quad_box_length           </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the side length of the smallest quadtree box containing two points. 
<p>
Quadtree Box Length <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p1</em>&nbsp;</td><td>First point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p2</em>&nbsp;</td><td>Second point </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The side length of the smallest quadtree box containing p1 and p2 </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="zorder__lt_8hpp-source.html">zorder_lt.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Oct 30 02:04:20 2010 for STANN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
